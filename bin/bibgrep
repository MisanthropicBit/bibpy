#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""bibgrep: Grep for bib(la)tex files.

The tool has been designed to have the same parameters as the ordinary grep
when this is sensible. To get all articles where the author contains 'Johnson'
and the article is from 2010 or beyond:

>>> bibgrep --entry="article" --field="author~Johnson" --field="year>=2010"

The entry and field arguments take strings in a special mini-language format.
For entries, the (informal) format is:

"[!][~]<entry_type>"

where <entry_type> is 'article', 'inproceedings' etc. The exclamation mark
denotes negation, and the tilde denotes approximate matches where the text must
contain the <entry_type>. For example, '~ceed' would match 'proceedings',
'inproceedings' and 'mvproceedings' entries. The format for fields is slightly
more involved:

"[!]<field_name>(=|~)<field_value>"
"[!]<field_name>(<|>|<=|>=|=)<field_numeric_value>"

All punctuation have the same meaning as for entries. The second format applies
only to fields with numeric values, e.g.:

>>> bibgrep --field="year>=2001" --field="10<volume<=50"

which selects all entries from 2001 and forward as well as fields with a volume
number in the range ]0;50].

"""

import argparse
import bibpy
import bibpy.tools
import fnmatch
import itertools
import operator
import re
import os
import sys

__author__ = 'Alexander Asp Bock'
__version__ = '0.1.0'
__license__ = 'MIT'

# TODO: How to combine predicates with '&&' and '||'?
# TODO: Enable negation of ranges, intervals etc.
# TODO: How to circumvent bash's history substitution syntax? ('!')

_DESCRIPTION = """Filter bib entries that satisfy user-defined predicates on
entry types and fields."""

_NAME_TO_OPERATOR = {
    '<':  operator.lt,
    '>':  operator.gt,
    '<=': operator.le,
    '>=': operator.ge
}


class BibgrepError(Exception):
    """Exception class for bibgrep-specific errors."""

    pass


def iter_files(names, pattern, recursive):
    """Yield all files matching a specific file pattern in a directory."""
    for name in names:
        if os.path.isdir(name):
            if not recursive:
                sys.exit("bibgrep: '{0}' is a directory, use [-r, --recursive]"
                         " to recurse into directories".format(name))
            else:
                for root, dirs, files in os.walk(name):
                    for filename in fnmatch.filter(files, pattern):
                        yield os.path.join(root, filename)
        else:
            yield name


def approx_field_predicate(field, value, args):
    """Return a function that does an approximate match of a string."""
    flags = re.I if args.ignore_case else 0

    def _approx_match(entry):
        field_value = getattr(entry, field, '')

        if field_value is None:
            return False
        else:
            return re.search(value, field_value, flags)

    return _approx_match


def exact_field_predicate(field, value, args):
    """Return a function that does an approximate match of a string."""
    func = str.lower if args.ignore_case else str

    def _exact_match(entry):
        return func(getattr(entry, field, '')) == func(value)

    return _exact_match


def field_occurrence_predicate(tokens):
    fields = [str.lower(t) if tokens[0] != '!' else tokens[1:] for t in tokens]

    def _field_occurrence(entry):
        return all([hasattr(entry, f) and getattr(entry, f, False)
                    for f in fields])

    return _field_occurrence


def negate(f):
    """Return a new function that negates the boolean result of f."""
    def _negate(entry):
        return not f(entry)

    return _negate


def operator_from_string(op_name):
    """Return an operator function from its string equivalent."""
    op = _NAME_TO_OPERATOR.get(op_name, None)

    if op is None:
        raise ValueError("Error: Invalid operator '" + op_name + "'")

    return op


def comparison_predicate(field, op_name, value):
    """Return a predicate function that compares a field to a value."""
    operator = operator_from_string(op_name)

    def _comparison_predicate(entry):
        attr = getattr(entry, field)

        try:
            return attr and operator(int(attr), int(value))
        except ValueError:
            raise BibgrepError("Cannot compare '{0}' with '{1}'"
                               .format(value, attr))

    return _comparison_predicate


def interval_predicate(field, lower, upper):
    """Return a predicate function that checks if a field is in an interval."""
    ilower = int(lower)
    iupper = int(upper)

    if ilower > iupper:
        raise ValueError("Error: Lower bound must be <= upper bound")

    def _interval_predicate(entry):
        attr = getattr(entry, field)

        try:
            return attr and ilower <= int(attr) <= iupper
        except ValueError:
            raise BibgrepError("Cannot compare '{0}' with interval "
                               "[{1}, {2}]".format(attr, lower, upper))

    return _interval_predicate


def range_predicate(lower, op_name1, field, op_name2, upper):
    """Return a predicate function that checks if a field is in a range.

    Example: '1 <= series < 10'

    """
    ilower = int(lower)
    iupper = int(upper)

    if ilower > iupper:
        raise ValueError("Error: Lower bound must be <= upper bound")

    operator1 = operator_from_string(op_name1)
    operator2 = operator_from_string(op_name2)

    def _range_predicate(entry):
        attr = getattr(entry, field)

        try:
            if attr:
                iattr = int(attr)
                return operator1(ilower, iattr) and operator2(iattr, iupper)
        except ValueError:
            raise BibgrepError("Cannot compare '{0}' with range "
                               "{1} {2} field {3} {4}"
                               .format(attr, lower, op_name1, op_name2, upper))

    return _range_predicate


def construct_key_entry_predicate(name, key, tokens, args):
    """Return a key/entry predicate to test if they are of given types."""
    f = None

    if not set(tokens[0]).issubset(set('!~')):
        raise ValueError("Error: Invalid field operator(s) '" + tokens[0] +
                         "'")

    if '~' in tokens[0]:
        f = approx_field_predicate(key, tokens[1], args)
    else:
        f = exact_field_predicate(key, tokens[1], args)

    if '!' in tokens[0]:
        f = negate(f)

    return f


def construct_field_predicate(name, key, tokens, args):
    """Construct and return a function that reflects the parsed query."""
    if name == 'field':
        if tokens[1] == '=':
            return exact_field_predicate(tokens[0], tokens[2], args)
        elif tokens[1] == '~':
            return approx_field_predicate(tokens[0], tokens[2], args)
        else:
            raise ValueError("Error: Invalid field operator '" + tokens[1] +
                             "'")
    elif name == 'field_occurrence':
        return field_occurrence_predicate(tokens)
    elif name == 'comparison':
        return comparison_predicate(*tokens)
    elif name == 'interval':
        return interval_predicate(tokens[0], tokens[2], tokens[3])
    elif name == 'range':
        return range_predicate(*tokens)
    else:
        raise ValueError("Error: Invalid field query syntax")


def construct_predicates(values, predicate_func, key,
                         pred_combiner, args):
    """Return a list of predicates on entries ."""
    # Parse and compose all predicates on values given on the command line
    predicates = []

    for value in values:
        name, tokens = bibpy.tools.parse_query(value, key)
        predicates.append(predicate_func(name, key, tokens, args))

    return bibpy.tools.compose_predicates(predicates, pred_combiner)


def filter_entries(entries, entry_predicate, key_predicate, field_predicate):
    """Filter entries based on predicates on entry type, key and fields."""
    for entry in entries:
        if key_predicate(entry) or entry_predicate(entry) or\
                field_predicate(entry):
            yield entry


def unique_entries(entries):
    """Remove duplicates from a set of entries."""
    return [k for k, _ in itertools.groupby(entries)]


if __name__ == "__main__":
    version_format = bibpy.tools.version_format()

    parser = argparse.ArgumentParser(prog='bibgrep', description=_DESCRIPTION)
    parser.add_argument('-v', '--version', action='version',
                        version=version_format.format(__version__))
    parser.add_argument('-e', '--entry', action='append',
                        help='Print the entries for the matching entry type')
    parser.add_argument('-k', '--key', action='append', dest='keys',
                        help='Print the entries with the '
                             'exact or similar key. For '
                             'example, --key="article1 | '
                             'article2" prints the entries with '
                             'keys that match either')
    parser.add_argument('-f', '--field', type=str, action='append',
                        dest='fields',
                        help='Print the entries that satisfy the list of field'
                             ' constraints')
    parser.add_argument('-c', '--count', action='store_true',
                        help='Only a count of selected lines is written to '
                             'standard output. If -n is given, prints a grand '
                             'total')
    parser.add_argument('-i', '--ignore-case', action='store_true',
                        help='Perform case insensitive matching. By default, '
                             'bibgrep is case sensitive')
    parser.add_argument('-r', '--recursive', action='store_true',
                        help='Recursively search subdirectories listed')
    parser.add_argument('-u', '--unique', action='store_true',
                        help='Print only one entry if duplicates are '
                             'encountered')
    parser.add_argument('-n', '--no-filenames', action='store_true',
                        help='Do not print filename headers before each entry '
                             'when --count is given. Overrides '
                             '--abbreviate-filenames')
    parser.add_argument('-a', '--abbreviate-filenames', action='store_true',
                        help='Display only the filename and not the full path '
                             'when --count is given')

    args, rest = parser.parse_known_args()

    key_predicate = bibpy.tools.always_false
    entry_predicate = bibpy.tools.always_false
    field_predicate = bibpy.tools.always_false

    try:
        if args.keys:
            key_predicate = construct_predicates(args.keys,
                                                 construct_key_entry_predicate,
                                                 'entry_key',
                                                 any,
                                                 args)

        if args.entry:
            entry_types = [e for es in args.entry
                           for e in map(str.strip, es.split(','))]
            entry_predicate =\
                construct_predicates(entry_types,
                                     construct_key_entry_predicate,
                                     'entry_type', any, args)

        if args.fields:
            field_predicate = construct_predicates(args.fields,
                                                   construct_field_predicate,
                                                   'field',
                                                   any, args)
    except (ValueError, bibpy.error.ParseException) as e:
        sys.exit(str(e))

    if not args.keys and not args.entry and not args.fields:
        # If no constraints are defined, all entries pass
        key_predicate = bibpy.tools.always_true
        entry_predicate = bibpy.tools.always_true
        field_predicate = bibpy.tools.always_true

    filtered_entries = []
    total_count = 0

    try:
        if not rest:
            entries = bibpy.read_file(sys.stdin,
                                      format='relaxed').entries

            if args.unique:
                entries = unique_entries(entries)

            filtered_entries = filter_entries(entries, entry_predicate,
                                              key_predicate, field_predicate)

            if args.count:
                num_entries = len(list(filtered_entries))
                total_count += num_entries
                filtered_entries = []
        else:
            for filename in iter_files(rest, '*.bib', args.recursive):
                # NOTE: Use scanFile if it ever gets into pyparsing to lazily
                # read and filter the bib source(s)
                entries = bibpy.read_file(filename, format='relaxed').entries

                if args.unique:
                    entries = unique_entries(entries)

                filtered_entries += list(filter_entries(entries,
                                                        entry_predicate,
                                                        key_predicate,
                                                        field_predicate))
                if args.count:
                    if args.no_filenames:
                        total_count += len(filtered_entries)
                    else:
                        if args.abbreviate_filenames:
                            filename = os.path.basename(filename)

                        print("{0}:{1}".format(filename,
                                               len(filtered_entries)))

                    filtered_entries = []
    except bibpy.error.ParseException as ex:
        sys.exit("bibgrep: {0}".format(ex))
    except BibgrepError as ex:
        sys.exit("bibgrep: {0}".format(ex))
    except KeyboardInterrupt:
        sys.exit(1)

    if args.count and (args.no_filenames or not rest):
        print(total_count)

    if filtered_entries:
        # Write all filtered entries to sys.stdout
        print(bibpy.write_string(filtered_entries))
